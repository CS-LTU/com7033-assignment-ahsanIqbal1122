feat: Implement secure user authentication system

PROBLEM SOLVED:
- Users needed secure login/registration with role-based access (admin/doctor/patient)
- Passwords must be securely hashed to prevent breach damage
- Session management required for persistent login state

IMPLEMENTATION:
- Created login() and register_doctor()/register_patient() routes
- Implemented scrypt password hashing using Werkzeug security module
- Added session-based authentication with Flask session management
- Implemented role-based access control (admin/doctor/patient roles)

SECURITY DECISIONS:
1. Scrypt hashing (32,768 iterations):
   - Much slower than bcrypt/SHA256 (takes ~1 second per hash)
   - Makes brute force attacks prohibitively expensive
   - Random salt added automatically by generate_password_hash()

2. Parameterized SQL queries:
   - All queries use ? placeholders to prevent SQL injection
   - Even if username contains malicious SQL, it's treated as literal data

3. Time-constant password comparison:
   - check_password_hash() uses timing-safe comparison
   - Prevents timing attacks that could leak password info

4. Session security:
   - Session expires on browser close
   - User role verified on each protected route
   - Redirect to appropriate dashboard based on role

DATABASE DESIGN:
- users table: id, username, password_hash, role, approved
- Index on username for fast lookup during login
- approved column allows admin to control user activation

VALIDATION:
- Username: minimum 3 chars, unique (checked before insert)
- Password: minimum 6 chars
- Role: enum check (must be admin/doctor/patient)

TESTING PERFORMED:
1. Register new doctor account → password stored as hash only ✓
2. Login with valid credentials → session created, redirected to dashboard ✓
3. Login with wrong password → login failed, no session ✓
4. SQL injection attempt blocked ✓

WHAT I LEARNED:
- Scrypt is superior to bcrypt for password hashing
- Salt randomization prevents rainbow table attacks
- Time-constant comparison prevents timing attacks
- Role-based access control requires checking user.role on every protected route
- Session management in Flask requires careful handling of user state
